\Chapter{Mérések}

% Külön szakaszokban bemutatni az egyes algoritmusokat
% Szerkezete: rövid matematikai bevezetés, C implementáció ismertetése (referencia képpen), Rust implementáció, futtatások eredményei.
% 5-8 módszer (szakasz)
% Input méret függvényében az eredményeket grafikusan ábrázolni.

\section{Numerikus integrálás}

\subsection{Trapézszabály}
\subsubsection{Rövid matematikai bevezetés}
A trapézszabály határozott integrálok meghatározására alkalmas közelítő módszer, amely egy adott intervallumba eső függvénygörbe alatti területet a függvénygörbe (vég)pontjaira illesztett trapézzal közelíti. Azaz, ha a és b számok az intervallum végpontjai, akkor:
\[ \int_{a}^{b} f(x) dx \approx (b-a) * \frac{f(a) + f(b)}{2} \]
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust, style=boxed]
fn trapedozial_rule(a: f32, b: f32, n: i32) -> f32 {
  let mut _x: f32;
  let mut _s: f32;
  let h: f32;
  
  h = (b-a) / (n as f32);
  _x = a;
  _s = 0.0;
  for _i in 1..n {
	  _x += h;
	  _s += parameter_function(_x);
  }
  return 0.5 * (parameter_function(a) + 2.0 * _s + parameter_function(b) );
}
\end{lstlisting}

\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\subsection{Iteratív trapézszabály}
\subsubsection{Rövid matematikai bevezetés}

\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust]
fn q_trapedozial_rule(a: f32, b: f32) -> f32 {
  const J_MAX: i32 = 20;
  const EPS: f32 =  0.00001;
  
  let mut s: f32 = 0.0;
  let olds: f32;
  
  olds = -0.00000000000000000000000000001;
  println!("{}", olds);
  for j in 0..J_MAX {
	  s = trapedozial_rule(a, b, j);
	  if j > 5 {
		  if (s-olds).abs() < EPS * olds.abs() {
			  if s == 0.0 && olds == 0.0 {
				  return s;
			  }
		  }
	  }
  }
  return s;
}
\end{lstlisting}

\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\subsection{Iteratív Simpson-módszer}
\subsubsection{Rövid matematikai bevezetés}
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust]
fn q_simpsons_rule(a: f32, b: f32) -> f32 {
  const J_MAX: i32 = 20;
  const EPS: f32 = 0.000001;
	  
  let mut s: f32 = 0.0;
  let mut st: f32;
  let mut ost: f32;
  let mut os: f32;
  
  os = -0.00000000000000000000000000001;
  ost = os;
  
  for j in 0..J_MAX {
	  st = trapedozial_rule(a, b, j);
	  s = (4.0 * st - ost) / 3.0;
	  if j < 5 {
		  if (s-os).abs() < EPS * os.abs() || (s == 0.0 && os == 0.0) {
			  return s;
		  }
	  }
	  os = s;
	  ost = st;
  }
  return s;
}
\end{lstlisting}
\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\subsection{Gauss-Legendre-módszer}
\subsubsection{Rövid matematikai bevezetés}
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust]
fn q_gauss_legendre(a: f32, b: f32) -> f32 {
  let xr: f32;
  let xm: f32;
  let mut dx: f32;
  let mut s: f32;
  
  const X: [f32; 6] = [0.0, 0.1488743389, 0.4333953941, 0.6794095682, 0.8650633666,0.9739065285];
  const W: [f32; 6] = [0.0, 0.2955242247, 0.2692667193, 0.2190863625, 0.1494513491, 0.0666713443];
  
  xm = 0.5 * (b + a);
  xr = 0.5 * (b - a);
  
  s = 0.0;
  
  for j in 0..5 {
	  dx = xr * X[j];
	  s += W[j] * parameter_function(xm + dx) + parameter_function(xm - dx);
  }
  
  let result: f32 = s * xr;
  return result;
}  
\end{lstlisting}
\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\section{Rendezés}

\subsection{Kupac-rendezés}
\subsubsection{Rövid matematikai bevezetés}
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust]
fn heapify(a: &mut [f32], n: usize, i: usize) {
	let mut largest: usize = i;
	let l = 2 * i + 1;
	let r = 2 * i + 2;
	
	if r < n && a[i] < a[l] {
		largest = l;
	}
	
	if r < n && a[largest] < a[r] {
		largest = r;
	}
	
	if largest != i {
		let temp = a[largest];
		a[largest] = a[i];
		a[i] = temp;
		
		heapify(a, n, largest);
	}
}

fn heapsort(n: usize, a: &mut [f32]) {
	let mut i: usize = n;
	while i > 0 {
		heapify(a, n, i);
		i -= 1;
	}

	i = n -1;
	while i > 0 {
		let temp = a[0];
		a[0] = a[i];
		a[i] = temp;
		heapify(a, i, 0);
		i -= 1;
	}
}
\end{lstlisting}
\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\subsection{Shell-rendezés}
\subsubsection{Rövid matematikai bevezetés}
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}[language=Rust]
void shell_sort(int n, ) {
  int gap = (n / 2);
  float temp;
  int j;

  while (gap > 0) {
      for (i = gap; i < n; i++) {
          temp = a[i];

          j = 1;
          while (j >= gap && a[j-gap]) > temp) {
              a[j] = a[j-gap];
              j -= gap;
          }
          a[j] = temp;
      }
      gap /= 2;
  }
}



\end{lstlisting}
\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)

\subsection{Gyorsrendezés (Quicksort)}
\subsubsection{Rövid matematikai bevezetés}
\subsubsection{C nyelvű referencia-implementáció}
\subsubsection{Az algoritmus egy implementációja Rustban}
\begin{lstlisting}
  
\end{lstlisting}
\subsubsection{Futtatások eredményei} % input méret függvényében eredmény grafika)
