\Chapter{Összegzés}
A dolgozatom alapján belátható, hogy a Rust programozási nyelvként egy ígéretes kezdeményezés, ami a teljesítményt illetően összehasonlítható a hasonló okból megbecsült C/C++ nyelvekkel. A nem is feltétlenül egyedi, de jól átgondolt nyelvi elemeinek köszönhetően a legtöbb hiba fordításidőben kiderül, ami nagy segítség a Rust nyelven programozók számára.

A rendszerprogramozás mellett a webfejlesztés, és a játékprogram-fejlesztés területe mellet már operációs rendszert is fejlesztenek vele.

Népszerűsége egyre növekszik a programozók körében, azonban a Rust ökoszisztémája továbbra is nélkülözi a kifinomult fejlesztői eszközöket. Integrált fejlesztői környezet a dolgozat írásakor még nem létezik olyan minőségben, mint a régebbi programozási nyelvekhez, mint például a C, C++, C\# vagy Java esetében.

Azonban hasznos tulajdonságai mellett sem elhanyagolható tény, hogy még mindig nem egy kiforrott nyelv. Látható, hogy a fájlbeolvasás a szabványos függvénykönyvtárbeli eszközökkel nagyon lassú a C-hez képest. A futási idők mérésénél például egy olyan esettel találkoztam, hogy a \lstinline{Duration} struktúrához több olyan metódus is létezik, amely az időtartam numerikus értékének kinyerésére szolgál. A mérések céljából a leginkább hasznosnak vélt \lstinline{as_float_secs} metódus, amely a másodperceket törtrészükkel együtt adja vissza, csak a \lstinline{nightly} API-val érhető el, ellenben a nanoszekundumokat, mikroszekundumokat visszaadó metódusok már a stabil API részei.
%https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_float_secs

Ezen kívül vannak olyan be nem mutatott potenciáljai a Rust nyelvnek, amely a szakdolgozatnak nem témája. Ilyen például a viszonylag egyszerűen kezelhető párhuzamosság, amellyel tovább javítható a teljesítmény.

A numerikus módszerek implementálása Rustban összességében nem körülményesebb feladat, mint C-ben. Az ebben a dolgozatban bemutatott módszerek esetén az alapértelmezetten immutable változókra, az ownership-szabályokra, illetve a határozottan előjel nélküli (\lstinline{usize}) egész indexekre kellett a leginkább figyelni. Ezeken a nyelvi jellemzőkön kívül az elkészült forráskód hasonló a C-s megfelelőjéhez. Bemutatásra kerültek rendezési, numerikus integrálást és lineáris interpolációt megvalósító függvények.

Megjegyzendő, hogy vannak már olyan numerikus számításokra alkalmazható könyvtárak Rusthoz, amelyek jóval túlmutatnak a szakdolgozatomban bemutatott függvény-gyűjteményen, mint például a Peroxide. %https://crates.io/crates/peroxide

Ellenben jelenleg nem érhető el olyan széleskörű funkcionalitást nyújtó, és relatíve egyszerűen használható függvénykönyvtár numerikus problémákra, mint például az R, vagy a Python nyelvekhez.

A teljesítménymérések után megállapítható, hogy az eddig teljesítménykritikus problémák esetén gyakran alkalmazott C/C++ nyelvekhez hasonló, nem ritkán még jobb teljesítmény érhető el a Rust segítéségével. Az ownership-szabályok mentén meghatározott memóriakezelés egyrészt biztosítja, hogy nincs futásidőben szükség garbage collectorra, így a Rust nyelvű implementációk memóriafoglalása nem tér el jelentősen a C-s megvalósításokétól. Másrészt, lehetetlenné teszi az olyan memóriahibák létrehozását, mint a dangling pointer, vagy a duplán felszabadított memóriaterület. A fordításkor létrejövő bináris állományok terén a \lstinline{rustc} fordító még mindig nagyobb méretet eredményez, mint a már 8 főverziót megért \lstinline{gcc} fordítóprogram a C esetében.

Összefoglalva megállapítható, hogy a Rust alkalmas általános célú programozási nyelvnek, teljesítményre és memóriabiztonságra egyszerre fókuszáló rendszerprogramozási nyelvnek. Így numerikus módszerek számítógépi megvalósítására is, amelyekhez kiváló teljesítménymutatóival járul hozzá.
